header
{
// This source file was generated by ANTLR. Do not edit manually!
package org.epic.core.parser;
}

class LexExpectHereDocEnd extends Lexer("org.epic.core.parser.LexExpectHereDocEndBase");
options
{
	k = 2;
	charVocabulary = '\0'..'\377' | '\u0080'..'\u00FF' | '\u0100'..'\u017F' | '\u0180'..'\u024F';
}
{
	private boolean endOfHeredoc;
	
	public void setInputState(LexerSharedInputState state)
    {
        super.setInputState(state);
        endOfHeredoc = false;
    }
}

CLOSE_HEREDOC:
	(HEREDOC_LINE { if (endOfHeredoc) break; })+
	{
		endOfHeredoc = false;
		getParent().pop();
	}
	;

protected
HEREDOC_LINE:
	t:HEREDOC_LINE_CHARS
	(NEWLINE { endOfHeredoc = terminator.equals(t.getText()) || maxLinesExceeded(); } |
	'\uFFFF'! { endOfHeredoc = true; })
	;

protected
HEREDOC_LINE_CHARS:
	(NOTNEWLINE)*
	;

protected
NEWLINE:
	(
	 '\r' '\n' |	// DOS
     '\r' |			// MacOS
     '\n'			// UNIX
    )
    { newline(); }
    ;

protected
NOTNEWLINE:
	~('\r' | '\n' | '\uFFFF')
	;